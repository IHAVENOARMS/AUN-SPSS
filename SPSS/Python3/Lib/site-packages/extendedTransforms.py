#!/usr/bin/env python
# This module provides a collection of transformations not available in the regular SPSS 
# transformation system.
#/***********************************************************************
# * Licensed Materials - Property of IBM 
# *
# * IBM SPSS Products: Statistics Common
# *
# * (C) Copyright IBM Corp. 1989, 2016
# *
# * US Government Users Restricted Rights - Use, duplication or disclosure
# * restricted by GSA ADP Schedule Contract with IBM Corp. 
# ************************************************************************/

# These functions can conveniently be used as SPSS transformations by 
# using the SPSSINC TRANS extension command or by referencing them via 
# the Tfunctions class in the trans.py module.

"""Functions designed to be used with the trans module to carry out one or more transformations on casewise data.
search:                       search a string for a match to a regular expression, case sensitive or not
subs:                         replace occurrences of a regular expression pattern with specified values
templatesub:                  substitue values in a template expression
levenshteindistance:          calculate similarity between two strings
soundex:                      calculate the soundex value of a string (a rough phonetic encoding)
nysiis:                       enhanced sound encoding (claimed superior to soundex for surnames)
soundexallwords:              calculate the soundex value for each word in a string and return a blank-separated string
median:                       median of a list of values
mode:                         mode of a list of values
multimode:                    up to n modes of a list of values
matchcount:                   compare value with list of values and count matches using
                                  standard or custom comparison function
strtodatetime:                convert a date/time string to an SPSS datetime value using a pattern
datetimetostr:                convert an SPSS date/time value to a string using a pattern
lookup:                       return a value from a table lookup
vlookup:                      return a value from a table lookup (more convenient than lookup w SPSSINC TRANS)
vlookupinterval:              return a value from a table lookup using intervals
sphDist:                      calculate distance between two points on earth using spherical approximation
ellipseDist:                  calculate distance between two points on earth using ellipsoidal approximation
jaroWinkler                   calculate Jaro-Winkler string similarity measure
extractDummies                extract a set of binary variables from a value coded in powers of 2
packDummies                   pack a sequence of numeric and/or string values into a single float
translatechar                 map characters according to a conversion table
countWkdays                   count number of days between two dates that are not excluded
vlookupgroupinterval          return a value associated with a group and a set of intervals for that group
countDaysWExclusions          count days in interval exclusing specificied weekdays and other dates
DiceStringSimilarity          compare strings using Dice bigram metric.
Dictdict                      find best match of strings using Dice metric
setRandomSeed                 initialize random number generator
invGaussian                   inverse Gaussian distribution random numbers
triangular                    triangular random numbers
"""

# history
# 2006-sep-17 initial version
# 2006-oct-19 add matchcount function
# 2007-jun-01 add sphDist, ellipseDist
# 2008-aug-02 add jaroWinkler
# 2009-jun-03  Unicode support in nysiis
# 2009-sep-17 add extractDummies and PackDummies functions and subf function version of subs
# 2009-sep-28 add mode, multimode, translatechar
# 2009-dec-23 add vlookup funciton
# 2011-apr-10 add vlookupinterval
# 2012-feb-08 add countWkdays
# 2012-apr-02 update attribution notice for ellipse calculations
# 2012-sep-18 add vlookupgroupinterval
# 2013-may-17 add countDaysWExclusions
# 2013-aug-07 add DiceStringSimilarity, Dictdict
# 2013-oct-02 add inverse Gaussian, triangular distributions and setRandomSeed
# 2014-oct-26 support multiple values in vlookup and vlookupinterval
# 2016-nov-23 add missing value protection and out-of-bounds protection to sphDist

__author__ =  'spss, jkp'
__version__=  '1.12.1'

import spss, spssaux
import collections
if int(spssaux.__version__[0]) < 2:
    raise ImportError("The trans module requires at least version 2.0.0 of spssaux.  Please download a newer version from www.spss.com/devcentral")
try:
    from trans import const
except:
    pass
import re, sys, operator, random, math

# search function for trans. Tfunction



# debugging
# makes debug apply only to the current thread
#try:
    #import wingdbstub
    #if wingdbstub.debugger != None:
        #import time
        #wingdbstub.debugger.StopDebug()
        #time.sleep(1)
        #wingdbstub.debugger.StartDebug()
    #import thread
    #wingdbstub.debugger.SetDebugThreads({thread.get_ident(): 1}, default_policy=0)
    ### for V19 use
    ####    ###SpssClient._heartBeat(False)
#except:
    #pass

class search(object):
    def __init__(self, string, pattern, ignorecase=False):
        """Search string for a match to regular expression.
        
        string is the string to search.
        pattern is a regular expression to apply.
        ignorecase indicates whether case is ignored in the search.  By default it is not
        The return value is three items
        - the matched string
        - the starting position of the match - first character is zero
        - the length of the match.
       In Tfunction, you can ignore arguments 2 and 3 if desired and just save the string back as an SPSS variable
       
       Example:
       tproc = trans.Tfunction(listwiseDeletion=True)
       tproc.append(extendedTransforms.search, 'match',8, ['names', trans.const('Peck')])
       tproc.append(extendedTransforms.search, ('match2','startpos','length'), (12,0,0), ['names', trans.const('Peck')])
       tproc.execute()
        """
        
        pat = re.compile(pattern, flags=(re.LOCALE | (ignorecase and re.IGNORECASE)))
        def f(string, pattern, unused=None):   # must accommodate same number of arguments as for constructor
            if string is None:
                return ("",0,0)
            m = pat.search(string)
            if m:
                return (m.group(), m.start(0), m.end(0)-m.start(0))
            else:
                return ("",0,0)
        self.func = f
        
class subs(object):
    def __init__(self, string, pattern, repl, ignorecase=False, count=0):
        """Search string for a match to regular expression, and replace matched occurrences.
        
        string is the string to search.
        pattern is a regular expression to apply.
        repl is the replacement string
        ignorecase indicates whether case is ignored in the search.
        count indicates the number of replacements to make.
        - 0, the default, means replace all
        - >0 is the maximum number
        ignorecase and count must be non-casewise
        The return value is the string with zero or more replacements.  This must be stored in a new string in SPSS as existing values
        cannot be changed here.
       
       Example:
       tproc = trans.Tfunction(listwiseDeletion=True)
       tproc.append(extendedTransforms.subs, 'newstring',20, ['names', trans.const('Peck'), trans.const('Smith'])
       tproc.execute()
        """
        
        pat = re.compile(pattern, flags=re.LOCALE | (ignorecase and re.IGNORECASE))
        def f(string, pattern, repl, ignorecase=ignorecase, count=count):
            if string is None or repl is None:
                return string
            if spssaux._isseq(repl):
                repl = repl[-1]
            m = pat.search(string)
            if m:
                return pat.sub(repl, string, count)
            else:
                return string
        self.func = f

def subf(string, pattern, repl, ignorecase=1, count=0):
    """Return string with specified substitutions.
    
    string is the input string variable
    pattern is the regular expression to apply.  It will be compiled on first call
    repl is the replacement expression
    if ignorecase, then case will be ignored
    count, defaulting to 0, specifies the number of occurrences to be replaced.  0 means all."""
    
    if string is None or repl is None:
        return string

    try:
        m = sys.modules["SPSSINC_TRANS"]
        if m.FIRST:
            m.FIRST = False
            m._ = re.compile(pattern, flags=re.LOCALE | (ignorecase and re.IGNORECASE))
        return m._.sub(repl, string, count)
    except (KeyError, AttributeError):
        return re.sub(pattern, string, repl, count)


# function for template-style substitution
from string import Template
import re

class templatesub(object):
    """Template pattern substitutions"""

    def __init__(self, template, *fields):
        """substitute field values into template and return substituted string.
        
        template is the template written with $fieldname or ${fieldname} syntax.  Use {} when a template field is followed by text
        that could be confused with the fieldname, e.g. "${sub}stitution".
        fields is a sequence of variable names or constants for substituting into template.
        fields are converted to strings if necessary, and trailing blanks are trimmed.
        A field name in the template may be used more than once.  The fields arguments are matched in order with the template fields
        in order of occurence after eliminating any occurences after the first.
        For example,
        templatesub("My name is $name, not $name2, repeat $name", 'truename', 'wrongname')
        might produce "My name is Psmith, not Smith, repeat Psmith"
        """
        self.template = Template(template)
        self.templatefieldswdups = re.findall(r"\${?([a-zA-Z0-9]+)}?",template)  #find all template fields (a list)
        self.templatefields = []
        for f in self.templatefieldswdups:
            if not f in self.templatefields:
                self.templatefields.append(f)
        self.d = {}
        def func(template, *fields):
            for i, key in enumerate(self.templatefields):
                self.d[key] = str(fields[i]).rstrip()
            return self.template.substitute(self.d)
        self.func = func
    

# by Magnus Lie Hetland (referenced from 
## http://www.merriampark.com/ld.htm
# Micahel Gilleland, Merriam Park Software

# The Levenshtein distance measures the similarity of two strings.
# The distance is the number of deletions, insertions, or substitutions required to transform one string into the other.
# Case is significant in counting these operations
#  It can be used for generic fuzzy matching such as might be done by a spell checker or as a name and address matching  
#  metrics, although those types of text often benefit from special handling.
#
#  Identical strings have distance zero, and larger distances mean greater differences between the strings.


def levenshteindistance(a,b):
    """Calculates the Levenshtein distance between strings a and b after removing trailing blanks.
    Returns a number or None.
    
    To use lookups against a dictionary, you can wrap this function in a class and use the __init__ method call to initialize a dictionary."""
    if not a or not b:
        return None
    a = a.rstrip()
    b = b.rstrip()
    n, m = len(a), len(b)
    if n > m:
        # Make sure n <= m, to use O(min(n,m)) space
        a,b = b,a
        n,m = m,n
        
    current = list(range(n+1))
    for i in range(1,m+1):
        previous, current = current, [i]+[0]*n
        for j in range(1,n+1):
            add, delete = previous[j]+1, current[j-1]+1
            change = previous[j-1]
            if a[j-1] != b[i-1]:
                change = change + 1
            current[j] = min(add, delete, change)
            
    return current[n]


# Title: soundex algorithm
#Submitter: Greg Jorgensen (other recipes)
#Last Updated: 2001/03/06
#Version no: 1.0

#    This is designed for English names, Scott David Daniels, 2001/06/23
#    If you have a significant number of non-English surnames, you might do well to alter the values in digits to improve your matches. 
#    For example, to accomodate a large number of Spanish surname data, you should count 'J' and 'L' ('L' because of the way 'll' is used) 
#    as vowels, setting their position in digit to '0'.
#    The basic assumptions of Soundex are that the consonants are more important than the vowels, and that the consonants are grouped into "confusable" groups. 
#    Coming up with a set of confusables for a language is not horribly tough, but remember: each group should contain all letters that are confusable 
#    with any of those in the group. a slightly better code for both English and Spanish names has digits = '01230120002055012623010202'. 

def soundex(name, len=4):
    """ soundex module conforming to Knuth's algorithm
        based on implementation 2000-12-24 by Gregory Jorgensen
        public domain
    """
    if not name:
        return ""
    name = str(name)
    
    # digits holds the soundex values for the alphabet
    digits = '01230120022455012623010202'
    sndx = ''
    fc = ''

    # translate alpha chars in name to soundex digits
    for c in name.upper():
        if c.isalpha():
            if not fc: fc = c   # remember first letter
            d = digits[ord(c)-ord('A')]
            # duplicate consecutive soundex digits are skipped
            if not sndx or (d != sndx[-1]):
                sndx += d

    # replace first digit with first alpha character
    sndx = fc + sndx[1:]

    # remove all 0s from the soundex code
    sndx = sndx.replace('0','')

    # return soundex code padded to len characters
    return (sndx + (len * '0'))[:len]



# 
# NYSIIS Third generation Soundex replacement
# Rev 0.1
#
# This implementation is free for re-use, without any encumbrance
# from the implementor:
#   Sean D. True, WebReply.Com
#
# Several graceful improvements were contributed by Tim Peters
# None of the remaining bugs are Tim's fault.
#
# Reimplemented from example at: http://www.dropby.com/NYSIIS.html
# Thanks Matt Perez

_DIGITre = re.compile(r"\d")
_JRSRre = re.compile(r" [JS]R$")
_VIre = re.compile(r" [VI]+$")
_VOWELWre = re.compile(r"[AEIOU]+W")
_VOWELre = re.compile(r"[AEIOU]+")
_AHHAre = re.compile(r"AH|HA")
_DUPSre = re.compile(r"([A-Z])\1+")


import string
_rep = string.replace

# Translate all alpha to upper case, everything else to whitespace
_tran = [" "] * 256
for c in range(ord('A'), ord('Z')+1):
    chrc = chr(c)
    _tran[c] = chrc
    _tran[ord(string.lower(chrc))] = chrc
del c, chrc

_tran = string.join(_tran, "")

# Return a string with no leading/trailing whitespace
# and possible single embedded whitespace
def collapse(s):
    if isinstance(s, str):
        s = string.translate(s, _tran, string.punctuation)
        s = string.join(string.split(s))
    else:   # unicode. punctuation argument is not supported for unicode characters
        s = [x in string.punctuation and " " or x for x in s]
        s = "".join(s).upper()
    return s


_suffixMap = {
    "IX": "IC",
    "EX": "EC",
    "YE": "Y",
    "EE": "Y",
    "IE": "Y",
    "DT": "D",
    "RT": "D",
    "RD": "D",
    "NT": "N",
    "ND": "N",
}

def nysiis(surname, debug=0):
    """Return nysiis encoding of a surname or an empty string if not valid"""
    
    surname = surname.rstrip()
    if surname =='' or _DIGITre.search(surname):
        return ""
    # Upper case, replace punctuation with whitespace
    surname = collapse(surname)
    # Drop troubling JR/SR suffixes
    surname = _JRSRre.sub("", surname)
    # Drop troubling III and IV
    surname = _VIre.sub("", surname)
    # Remove trailiing SZ
    while surname and surname[-1] in "SZ":
        surname = surname[:-1]
    # Initial MAC -> MC and PF -> F
    # XXX In 2.0, surname.startswith("MAC")
    if surname[:3] == "MAC":
        surname = "MC" + surname[3:]
    # XXX In 2.0, surname.startswith("PF")
    if surname[:2] == "PF":
        surname = surname[1:]
    # Change spelling on some suffixes
    # XXX This function returns None if len(surname) <= 2!
    if len(surname) > 2:
        suffix = surname[-2:]
        surname = surname[:-2] + _suffixMap.get(suffix, suffix)
        # Change 'EV' to 'EF' if not at start of name
        if len(surname) > 2 and string.find(surname[2:], "EV") > -1:
            surname = surname[:2] + _rep(surname[2:], "EV", "EF")
        # Save first vowel for later
        firstletter = surname[0]
        # Remove any 'W' that follows a vowel
        surname = _VOWELWre.sub("A", surname)
        # Replace all vowels with 'A'
        surname = _VOWELre.sub("A", surname)
        # Change GHT->GT, DG->G, PH->F
        for pattern, replacement in [("GHT","GT"),
                                     ("DG","G"),
                                     ("PH","F")]:
            surname = _rep(surname, pattern, replacement);
        # Change non-initial AH, or HA to just A
        surname = surname[0] + _AHHAre.sub("A", surname[1:])
        # Change KN->N, K->C
        surname = _rep(surname, "KN", "N")
        surname = _rep(surname, "K", "C")
        # Change non initial M->N, Q->G
        if len(surname) > 1:
            surname = surname[0] + _rep(surname[1:], "M", "N")
            surname = surname[0] + _rep(surname[1:], "Q", "G")
        for pattern, replacement in [("SH",  "S"),
                                     ("SCH", "S"),
                                     ("YW",  "Y")]:
            surname = _rep(surname, pattern, replacement)
        # If not first or last character, change 'Y' to 'A'
        if len(surname) > 2:
            first = surname[0]
            mid = surname[1:]
            last = ""
            if len(mid) > 2:
                last = mid[-1]
                mid = mid[:-1]
            surname = first + _rep(mid,"Y","A") + last
        # Change 'WR' to 'R'
        surname = _rep(surname, "WR", "R")
        # If not first character, change 'Z' to 'S'
        surname = surname[0] + _rep(surname, "Z", "S")
        if surname[-2:] == "AY":
            surname = surname[:-2] + "Y"
        # remove trailing vowels
        while surname and surname[-1] == "A":
            surname = surname[:-1]
        # remove all duplicated letters
        surname = _DUPSre.sub(r"\1", surname)
        # if first char of original surname was a vowel,
        # append it to the code
        if firstletter in "AEIOU":
            surname = firstletter + surname[1:]
        return surname

def median(*lis):
    """Return the median of a list of numeric values
    
    lis is a list containing the values.
    This code assumes that user missing values have been converted to None (default behavior for the cursor) or are sorted regularly
    """
    
    lisnomv = [item for item in lis if not item is None]
    lisnomv.sort()
    s = len(lisnomv)
    if s == 0:
        return None
    return (lisnomv[(s-1)/2] + lisnomv[s/2])/2


class soundexallwords(object):
    def __init__(self, string):
        """Calculate the soundex value of each word in string
        
        string is the string to search.
        The return value is a string of blank-separated soundex values.
        A word is defined as a sequence of one or more alphanumeric characters according to the current locale.
        For the simplest case, these characters would be upper- and lower-case letters, digits, and the underscore.
        To get rid of short words, you can apply the subs function in this module to the output of soundex to convert 
        a sequence of the form ".000" to ""
        """        
        pat = re.compile(r"\w+", flags=re.LOCALE )
        def f(string):
            if string is None:
                return ("",0,0)
            return " ".join([soundex(word) for word in pat.findall(string)])
        self.func = f

class matchcount(object):
    def __init__(self,term, cmpfunc=None, *args):
        """Count the number of equality tests passed between  term and the other arguments.  Return duple (matches, tests)
        
        Each argument in args is tested for equality with term.  If equal, the count is incremented by one.  The return includes the number of
        args found equal and the number of terms compared.  None (SYSMIS) is not considered equal to anything but is included in the count of tests.
        If cmpfunc is callable, it is used for the comparison instead of simple equality.
        It is called with the term parameter and each value in args, and it should return True or False.  
        Otherwise cmpfunc is considered to be one of the test values.  
        cmpfunc will be called regardless of whether term is sysmis or not, so it can handle sysmis as it likes.
        
        Example:
        matchcount('x', trans.const(100), 'y', 'z')
          if x = 100 returns (1,3) if neither y nor z == 100, or (2,3) if one of y and z is 100 or (3,3) if y and z are both 100.
          if x is None, the result would always be (0,3)
        matchcount('x', f, 'y', 'z')
          would call f(x,y) and f(x,z) for the test.
        the cmpfunc argument might be used, for example, to make a string comparison function case insensitive:
          matchcount('x', cmpfunc=lambda x, y: x.upper() == y.upper(), 'y','z')
        """
        if isinstance(cmpfunc, collections.Callable):
            def f(term, cmpfunc, *args):
                matches = 0
                for value in args:
                    matches += cmpfunc(term, value)
                return (matches,  len(args))
        else:
            def f(term, cmpfunc, *args):
                matches = 0
                for value in (cmpfunc,)+ args:
                    matches += term == value
                return (matches, len(args)+1)
        self.func = f
        
# functions for converting complex date/time representations to SPSS datetime values and vice versa
from time import strptime, strftime
from spssdata import yrmodasec,CvtSpssDatetime, Spssdata

def strtodatetime(value, pattern):
    """Convert a string value to an SPSS datetime value according to pattern.
    
    value is the string to convert.
    pattern is a pattern describing the date format.  
    If the value does not match the pattern, this function returns None
    Missing date are filled in as year=1900, month=1, day=1, hms all = 0, so this function should not generally be used with just time values
    
    Patterns are defined in the datetime Python module but include the following
    %a Locale's abbreviated weekday name.  
    %A Locale's full weekday name.  
    %b Locale's abbreviated month name.  
    %B Locale's full month name.  
    %c Locale's appropriate date and time representation.  
    %d Day of the month as a decimal number [01,31].  
    %H Hour (24-hour clock) as a decimal number [00,23].  
    %I Hour (12-hour clock) as a decimal number [01,12].  
    %j Day of the year as a decimal number [001,366].  
    %m Month as a decimal number [01,12].  
    %M Minute as a decimal number [00,59].  
    %p Locale's equivalent of either AM or PM. (1) 
    %S Second as a decimal number [00,61]. (2) 
    %U Week number of the year (Sunday as the first day of the week) as a decimal number [00,53]. 
    All days in a new year preceding the first Sunday are considered to be in week 0. (3) 
    %w Weekday as a decimal number [0(Sunday),6].  
    %W Week number of the year (Monday as the first day of the week) as a decimal number [00,53]. 
    All days in a new year preceding the first Monday are considered to be in week 0. (3) 
    %x Locale's appropriate date representation.  
    %X Locale's appropriate time representation.  
    %y Year without century as a decimal number [00,99].  
    %Y Year with century as a decimal number.  
    %Z Time zone name (no characters if no time zone exists).  
    %% A literal "%" character. 
    
    (1)When used with the strptime() function, the %p directive only affects the output hour field if the %I directive is used to parse the hour.
    (2)The range really is 0 to 61; this accounts for leap seconds and the (very rare) double leap seconds. 
    (3)When used with the strptime() function, %U and %W are only used in calculations when the day of the week and the year are specified. 
    
    Note: a two-digit year is assumed to refer to refer to the 21st century, which is probably  not what you want.
    Other characters included in the format string are matched literally, but a single blank matches any amount of white space
    Examples:
    value: "dec 31, 2006" would be described as the pattern "%b %d, %Y" in an English locale.
    value: "2006-36" (Julian date) matches "%Y-%j"
"""
    try:
        dt = strptime(value, pattern)
        spssdt = float(yrmodasec((dt[0], dt[1], dt[2])) + (dt[3]*60 + dt[4])*60 + dt[5])
    except KeyError:
        raise ValueError("date/time pattern is invalid: " + pattern)
    except:
        spssdt=None
    return spssdt


def datetimetostr(value, pattern):
    """Convert an SPSS datetime value to a string according to the supplied pattern.
    
    value is the datetime value to convert.
    pattern is a datetime pattern as described above
    Unconvertable values are returned as blank"""
    
    try:
        return strftime(pattern, CvtSpssDatetime(value).timetuple())
    except KeyError:
        raise ValueError("date/time pattern is invalid: " + pattern)
    except:
        return ""
    
    
class lookup(object):
    def __init__(self, keyvalue, lookupdict,nokey):
        """Return value associated with keyvalue in lookupdict or None
        
        keyvalue is the object providing the key for a table lookup.  If it is a string, trailing blanks are removed before the lookup
        lookupdict is a Python dictionary.  It is bound on the constructor call and ignored after that.
        nokey is the value to return if the key is not found in the dictionary.  Also bound in the constructor.
        If the table is large, you will probably want to set autoAttrib to False in the Tfunction constructor or specify a maximum attribute length.
       
       Example:
       tproc = trans.Tfunction(listwiseDeletion=True,autoAttrib=50)
       tproc.append(extendedTransforms.lookup, 'statename','a24', ['abbrev', trans.const(statedict), trans.const("??")])
       tproc.execute()
       
       # The init call could be used to read the dictionary from a file or otherwise construct it
        """
        
        def f(keyvalue, unused1=None, unused2=None):   # must accommodate same number of arguments as for constructor
            if isinstance(keyvalue, str):
                keyvalue = keyvalue.rstrip()
            return lookupdict.get(keyvalue, nokey)
        self.func = f

#import spssdata
#class vlookup(object):
    #def __init__(self, key, value, dataset):
        #table = dict(spssdata.Spssdata(indexes=[key, value], dataset=dataset, names=False).fetchall())
        #def f(x):
            #return table.get(x)
        #self.func = f
        
# Example using the SPSSINC TRANS extension command
#* The lookup table.
#data list free/ value(F8.0) akey(A1).
#begin data
#10 'a'
#20 'b'
#100 'z'
#end data.
#dataset name lookup.

#* The main dataset.
#data list free/x(f8.0) y(A2).
#begin data
#1 'a'
#2 'b'
#5 'a '
#10 ''
#1 'b'
#end data.
#dataset name main.
#dataset activate main.

#spssinc trans result = resultcodealpha
#/initial "extendedTransforms.vlookup('akey', 'value', 'lookup')"
#/formula func(y).

class vlookup(object):
    """Look up values according to a dictionary specified as an SPSS dataset"""
    def __init__(self, key, value, dataset):
        """key and value are variable names in the dataset named dataset
        value can be a single variable name or a list
        
        For string keys, lookups are made after trimming any trailing blanks
        The class creates a function named func that can be referenced for lookups"""
        
        spss.StartDataStep()
        try:
            ds = spss.Dataset(dataset)
            cases = ds.cases
            vl = ds.varlist
            keyvar = vl[key].index
            if not spssaux._isseq(value):
                value = [value]
            valuevar =[vl[val].index for val in value]
            table = {}
            for i in range(len(cases)):
                key = cases[i, keyvar][0]
                if isinstance(key, str):
                    key = key.rstrip()
                c = cases[i]
                table[key] = [c[jj] for jj in valuevar]
            def func(x):
                if isinstance(x, str):
                    x = x.rstrip()
                return table.get(x)
            self.func = func
        finally:
            spss.EndDataStep()

from bisect import bisect

# interval-based lookups
# Examples
 # lower is the bounds variable; value is the lookup value, which can be a list;
 # table is the dataset name
# No upper bounds on intervals:
# spssinc trans result=recode
#  /INITIAL 'extendedTransforms.vlookupinterval("table", "lower", "value")'
#  /FORMULA func(x).

# upper bounds supplied for intervals.  upper is the upper bound variable
# spssinc trans result=recode
#  /INITIAL 'extendedTransforms.vlookupinterval("table", "lower", "value", "upper")'
#  /FORMULA func(x).
#
# with a list of values
# spssinc trans result=val1 val2
#  /INITIAL 'extendedTransforms.vlookupinterval("table", "lower", 
#    ["value1", "value2"], "upper")'
#  /FORMULA func(x).

class vlookupinterval(object):
    """Look up values according to a set of intervals specified as an SPSS dataset"""
    
    def __init__( self, dataset, keylower, value, keyupper=None):
        """keylower names a variable of interval lower bounds
        value is the value to be returned for the interval
        value can be a list of variables
        dataset is the name of the dataset containing the bounds and values
        keyupper is an optional variable defining the upper limits of the intervals
        If keyupper is not specified, the sequence of values in the keylower
        variable defines the intervals
        
        Examples:
        -keyupper not specified
        keylower        value
        10                 1
        20                  2
        
        a lookup of a value < 10 returns None (sysmis)
        10 to 20 [10,20) returns 1
        20 or greater returns 2
        
        If keyupper is specified, the pairs [keylower, keyupper) define the intervals.
        If the last upper limit is None (sysmis), that interval extends to infinity.
        If a value is not contained within any interval, the result is None.
        If using keyupper and the intervals are not disjoint, the interval with the smaller
        lower limit wins.  If two lower limits are equal, the first one listed governs, but
        this is probably an error.
        
        For string keys, lookups are made after trimming any trailing blanks
        The class creates a function named func that can be referenced for lookups"""
        
        spss.StartDataStep()
        try:
            ds = spss.Dataset(dataset)
            cases = ds.cases
            vl = ds.varlist
            keylower = vl[keylower].index
            if keyupper is not None:
                keyupper = vl[keyupper].index
            #valuevar = vl[value].index
            if not spssaux._isseq(value):
                value = [value]
            valuevar =[vl[val].index for val in value]
            table = []
            keyup = None
            lentbl = len(cases)
            for i in range(lentbl):
                key = cases[i, keylower][0]  # interval lower limit
                if keyupper is not None:
                    keyup = cases[i, keyupper][0]  # optional upper limit
                    if keyup is None and i == lentbl-1:  # last upper bound can be None - treated as infinite
                        keyup = 1E100
                if key is None or (keyupper is not None and keyup is None):
                    raise ValueError("Table of lookup intervals contains a missing value for a bound.  Row: %s" % (i+1))
                if keyupper is not None and keyup is not None and keyup < key:
                    raise ValueError("Interval upper bound ls less than lower bound: %s, %s" % (key, keyup))
                if isinstance(key, str):
                    key = key.rstrip()
                    if keyupper is not None:
                        keyup = keyup.rstrip()   # will fail if upper key is not also a string
                #table.append((key, keyup, cases[i,valuevar][0]))   # (lower, upper, values)
                c = cases[i]
                table.append((key, keyup, [c[jj] for jj in valuevar]))   # (lower, upper, list of values)
            table = sorted(table)
            tbllower = [i for i,j,k in table]
            tblupper = [j for i,j,k in table]
            values = [k for i,j,k in table]
            values.insert(0, None)    # keys below lowest interval will have value None
            if len(tbllower) != len(set(tbllower)):
                raise ValueError("Table of lookup intervals contains a duplicate lower value")
            fil = [x for x in tblupper if x is not None]
            if len(fil) != len(set(fil)):
                raise ValueError("Table of lookup intervals contains a duplicate upper value")

            if keyupper is None:  # implicit upper bounds
                def func(x):
                    "Return the value(s) of the interval associated with x or None"
                    
                    if isinstance(x, str):
                        x = x.rstrip()
                    index = bisect(tbllower, x)
                    return values[index]
            else:   # explicit upper bounds
                def func(x):
                    "Return the value of the interval associated with x or None"
                    
                    if isinstance(x, str):
                        x = x.rstrip()
                    index = bisect(tbllower, x)
                    if (0< index < lentbl and x < tblupper[index-1]) or \
                       (index == lentbl and x < tblupper[-1]):
                        return values[index]
                    else:
                        return None                
            self.func = func
        except spss.SpssError:
            ds = None
            raise ValueError("Unable to access lookup dataset: %s" % dataset)
        finally:
            #if ds is not None:
                #ds.close()
            spss.EndDataStep()
            
# interval-based lookups including a subgroup
# Lookups are performed against a dataset containing
# - one or more variables that define groups
# - two variables that define the lower and upper bounds of each interval
# - a variable whose value is returned for the interval
# The dataset used for the lookup must be sorted by the group variables and the lower bound
# No check is made that the order is correct
# Example with one group variable
#* lookup dataset.
#data list list /group (a8) keylow keyhigh value.
#begin data.
#groupone 1 3 1.5
#groupone 4 6 5
#groupone 7 10 100
#grouptwo 1 2 1.5
#grouptwo 5 10 7.5
#groupone 50 50 -50
#end data.
#dataset name lookup.

#data list list /group (a8) values.
#begin data.
#grouptwo 6
#groupone 1
#groupone 2
#groupone 3
#groupone 100
#grouptwo 1.5
#grouptwo 10
#grouptwo 6
#groupthree 99
#groupone 7
#grouptwo 20
#groupone 10
#groupone 50
#end data.
#dataset name looktheseup.
#dataset active looktheseup.
#spssinc trans result = result
#/initial "extendedTransforms2.vlookupgroupinterval('lookup', 'group', 'keylow', 'keyhigh', 'value')"
#/formula func(group, values).

# Note that the variable names are quoted in the initial subcommand but not in the formula.
# With multiple variables defining the group, write them as a list, e.g.,
# splits=['group', 'subgroup']
            
class vlookupgroupinterval(object):
    """Look up values according to a set of intervals specified as an SPSS dataset"""
    def __init__(self, dataset, splits, keylow, keyhigh, value):
        """keylow names a variable of interval lower bounds
        keyhigh names a variable of corresponding upper bounds
        splits is a list of variables that define groups within which to search
        value is the value to be returned for the interval
        dataset is the name of the dataset containing the bounds and values
        splits is a value or list of values defining the splits
                
        The pairs [keylower, keyupper] define the intervals.
        If a value is not contained within any interval, the result is None.
        
        The class creates a function named func that can be referenced for lookups
        func has two parameters: split and x.  x is looked up in group split."""
        
        spss.StartDataStep()
        try:
            ds = spss.Dataset(dataset)
            cases = ds.cases
            vl = ds.varlist
            keylowindex = vl[keylow].index
            keyhighindex = vl[keyhigh].index
            valueindex = vl[value].index
            if not spssaux._isseq(splits):
                splits = [splits]     # optional to bracket splits if it is just one variable
            group = tuple(vl[v].index for v in splits)
            self.table = []
            self.breaks = {}
            lentbl = len(cases)
            # fetch data perhaps sorted by grouping variable(s) and numeric interval key
            
            # build lookup and value table and record group breakpoints
            first = True
            for i, data in enumerate(cases):
                if first:
                    prevkey = tuple(data[j] for j in group)
                    self.breaks[prevkey] = i
                    first = False
                if data[keylowindex] is None or data[keyhighindex] is None:
                    raise ValueError("Table of lookup intervals contains a missing value for a bound.  Row: %s" % (i+1))
                if data[keylowindex] > data[keyhighindex]:
                    raise ValueError("An interval lower bound exceeds its upper bound: %s, %s" \
                        % (data[keylowindex], data[keyhighindex]))
                exactkey = tuple(data[j] for j in group)
                self.table.append((exactkey, data[keylowindex], data[keyhighindex], data[valueindex]))
                # record location for search start to restrict to exact match on group identifier
                if not exactkey == prevkey:
                    self.breaks[prevkey] = (self.breaks[prevkey], i)
                    self.breaks[exactkey] = i
                    prevkey = exactkey
            self.breaks[exactkey] = (self.breaks[exactkey], i+1)  # finish the last interval list
                
            def func(split, x):
                "Return the value of the interval associated with x within split or None"
                
                if isinstance(split, list):
                    split = tuple(split)
                if not spssaux._isseq(split):
                    split = (split,)
                low, high = self.breaks.get(split, (None, None))
                if low is None:
                    return None
                index = self.bisect(x, low, high)
                # ensure in interval
                if index > 0 and self.table[index-1][2] >= x:
                    return self.table[index-1][3]
                else:
                    return None
                
            self.func = func
        except spss.SpssError:
            ds = None
            raise ValueError("Unable to access lookup dataset: %s" % dataset)
        finally:
            spss.EndDataStep()
            
    def bisect(self, x, low, high):
        """Return index for interval start <= x
        
        The return value i is such that all e in a[:i] have e <= x, and all e in
        a[i:] have e > x.  So if x already appears in the list, a.insert(x) will
        insert just after the rightmost x already there.
    
         low and high bound the
        slice of the items to be searched.
        """
        
        while low < high:
            mid = (low + high) // 2
            if x < self.table[mid][1]: 
                high = mid
            else: 
                low = mid + 1
        return low
    
def sphDist(lat1, lon1, lat2, lon2,  inradians=True):
    """Return distance in miles between two points on earth using spherical approximation.
    
    lat1, lon1 are the latitude and longitude of the first point
    lat2, lon2 are the latitude and longitude of the second point
    
    If inradians is True, coordinates are assumed to be in radians.  Otherwise they are converted"""
    
    if lat1 is None or lon1 is None or lat2 is None or lon2 is None:
        return None    
    try:
        if not inradians:
            lat1, lon1, lat2, lon2 = [radians(ang) for ang in [lat1, lon1, lat2, lon2]]
            term = max(-1., min(sin(lat1)* sin(lat2) + cos(lat1)*cos(lat2)*cos(lon2 - lon1),1.))
        return 3958.75 *acos(term)
    except:
        return None

# The function below is  based on transcribing and adapting code from
# http://www.movable-type.co.uk/scripts/latlong-vincenty.html
# which includes the note
#I offer these formulae & scripts for free use and adaptation as my contribution to the open-source 
#info-sphere from which I have received so much. You are welcome to re-use these scripts 
#[under a simple attribution license, without any warranty express or implied] 
#provided solely that you retain my copyright notice and a link to this page.[above]
#If you have any queries or find any problems, contact me at ku.oc.epyt-elbavom@oeg-stpircs.
#
#(c) 2002-2011 Chris Veness 

#Another useful source is
#http://search.cpan.org/~bluefeet/GIS-Distance-0.01001/lib/GIS/Distance/Vincenty.pm

# ellipsoid parameters
class Elp:
    a = 6378137.
    b = 6356752.314245
    f = (a-b) / a

from math import sin, cos, tan, acos, atan, atan2, radians, sqrt, pi

def ellipseDist(lat1, lon1, lat2, lon2, inradians=True):
    """Return the distance in miles between the two sets of coordinates  using an ellipsoidal approximation to the earth 
    
    Calculation uses Vincenty inverse ellipsoid formula with WGS-84 ellipsoid parameters.
    
    lat1 and lon1 are the latitude and longitude of the first point and lat2, lon2 of the second.
    if inradians is True, locations are in radians; otherwise they are in degrees.
    If the algorithm fails to converge, the return value is None, which will become SYSMIS when returned to SPSS
    
    The ellipsoid model is more accurrate than the simpler spherical approximation."""
    
    if lat1 is None or lon1 is None or lat2 is None or lon2 is None:
        return None
    if not inradians:
        lat1, lon1, lat2, lon2 = [radians(ang) for ang in [lat1, lon1, lat2, lon2]]
    u1, u2 = [atan((1-Elp.f) * tan(x)) for x in [lat1, lat2]]
    sinu1, sinu2 = sin(u1), sin(u2)
    cosu1, cosu2 = cos(u1), cos(u2)
    londif = lon2 - lon1
    
    lam = londif
    lamp = 2 * pi
    numiter = 50  # maximum number of iterations
    
    for i in range(numiter):
        if abs(lam - lamp) <= 1e-12:
            break
        sinLam = sin(lam)
        cosLam = cos(lam)
        sinSigma = sqrt((cosu2 * sinLam) **2 + (cosu1 * sinu2-sinu1 * cosu2 * cosLam)**2)
        if sinSigma == 0:
            return 0
        cosSigma = sinu1 * sinu2 + cosu1 * cosu2 * cosLam
        sigma = atan2(sinSigma, cosSigma)
        sinAlpha = cosu1 * cosu2 * sinLam / sinSigma
        cosSqAlpha = 1 - sinAlpha **2
        try:
            cos2SigmaM = cosSigma - 2 * sinu1 * sinu2 / cosSqAlpha
        except:
            cos2SigmaM = 0 # equatorial line
        c = (Elp.f/16) * cosSqAlpha * (4 + Elp.f * (4 - 3 * cosSqAlpha))
        lamp = lam
        lam = londif + (1 - c)  * Elp.f * sinAlpha\
            * (sigma + c * sinSigma* (cos2SigmaM + c * cosSigma * (-1 + 2 * cos2SigmaM **2)))
    else:
            return None
        
    uSq = cosSqAlpha * (Elp.a * Elp.a - Elp.b * Elp.b) / (Elp.b * Elp.b)
    A = 1 + uSq / 16384 * (4096+uSq * (-768 + uSq * (320-175 * uSq)))
    B = uSq/1024 * (256 + uSq * (-128 + uSq * (74-47 * uSq)))
    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1+2 * cos2SigmaM **2)- \
        B / 6 * cos2SigmaM * (-3 + 4 * sinSigma **2) * (-3 + 4 * cos2SigmaM **2)))
    s = Elp.b * A * (sigma - deltaSigma)
    return s * 0.000621371192  # convert meters to miles

# jaro-Winker string similarity measure

def jaroWinkler(s1, s2, prefixlen=4, dwt=.1, boostThreshold= .7):
    """return jaroWinker distance between two strings.
    
    s1 and s2 are compared.
    prefixlen is the required prefix length for extra credit.
    dwt is the weight for the prefix adjustment.
    Map both strings to lower case to ignore case in this metrix.
    
    If either string has length 0, return None.
    Leading and trailing blanks are ignored in these comparisons.
    
    The Jaro-Winkler metric exists in several variations and has a number of edge
    cases where implementations may differ.  Results here agree with
    Winkler, Overview of Record Linkage and Current Research Directions,
    Statistics #2006-2, US Census Bureay
    Table 6 test cases except for zero values in that table, which seem to be incorrect.
    No special provision is made here for such things as I vs 1 and O vs 0.
    """
    
    # J, the Jaro distance (0 <= J <= 1) is
    # (1/3)(m/len(s1) + m/len(s2) + (m - t)/m)
    # where m is the count of matching characters
    # t is the count of transpositions
    
    # matching is carried out in a window looking forward and backward by
    # max(len(s1), len(s2) / 2) - 1
    
    # each character in s1 is compared with its matching characters in s2
    # t is the number of different match characters /2
    
    # Jaro-Winker favors prefix matches
    # JW = J + L * dwt (1 - J)
    # where L is the length of the common prefix up to prefixlen.
    
    """
From http://lingpipe-blog.com/2006/12/13/code-spelunking-jaro-winkler-string-comparison/,
some clarifications attributed to Winkler.

The match phase is a greedy alignment that proceeds character by character t
hrough the first string, though the distance metric is symmetric (that, is reversing 
the order of arguments does not affect the result). For each character encountered 
n the first string, it is matched to the first unaligned character in the second string 
that is an exact character match. If there is no such character within the match 
range window, the character is left unaligned.

Step 2: Transpositions: After matching, the subsequence of characters actually 
matched in both strings is extracted. These subsequences will be the same length. 
The number of characters in one string that do not line up (by index in the matched 
subsequence) with identical characters in the other string is the number of "half 
transpositions". The total number of transpoisitons is the number of half transpositions
divided by two, rounding down."""
    
    s1, s2  = s1.strip(), s2.strip()
    s1len, s2len = float(len(s1)), float(len(s2))
    
    if s1len == 0 or s2len == 0:
        return None
    
    fmlist = mtable(s1, s2)  # get list of match indexes.
    m = len(fmlist)
    if m == 0:
        return 0.  # nothing matches

    t = 0
    for i in range(1, m):
        t += fmlist[i] < fmlist[i-1]
    t = float(t)
    m = float(m)
    
    J = (m/s1len + m / s2len + (m-t)/m)/3.
    if J <= boostThreshold:
        return J
    
    prefixmatch = 0
    stop = min(prefixlen, s1len, s2len)
    while prefixmatch < stop and s1[prefixmatch] == s2[prefixmatch]:
        prefixmatch += 1
        
    return J + dwt * prefixmatch * (1 - J)

def mtable(s1, s2):
    """Return a list of match character positions within the apropriate window"""
    
    s1len=  len(s1)
    s2len = len(s2)
    s2 = list(s2)
    width = max(max(s1len, s2len)/2 - 1, 0)
    mlist = []
    for i, c in enumerate(s1):
        start = max(0, i-width)
        end = min(i+ width+1, s2len)
        for j in range(start,end):
            if c == s2[j]:
                mlist.append(j)
                s2[j] = None
                break
    return mlist

def extractDummies(value, count=None, reversed=False, indexes=None):
    """Return a list of count or values where each is True or False (1/0) according to its bit setting
    
    value is a floating point or integer value from which to extract dummies
    count is the number of values to extract.  0< count <= 52
    reversed, if true, causes the order of the extracted list to be reversed.  By default
    the first value in the list matches the rightmost bit.
    By default, count values are extracted.  If indexes is specified, the bit
    positions listed in indexes are returned in the order listed, in which case there will be 
    exactly as many values returned as numbers listed in indexes.  Reverse is ignored in this case.
    indexes should be a string containing a comma-separated list of integers.
    Positions are numbered from 0 and from right to left.
    
    A set of values can be put into this format with the packDummies function"""
    
    value = int(value)
    if not count is None:
        count = int(count)
    if indexes:
        indexes = re.split("[ ,]", indexes)
        return [(value & 1<<int(index)) > 0 for index in indexes]
    else:
        result = [(value & 1<<i) > 0 for i in range(count)]
        if reversed:
            result.reverse()
        return result
    
def packDummies(values, initial=0, indexes=None):
    """Return a float(!) whose bitwise values are 1 or 0 based on values
    
    values is a sequence of numbers and/or strings or a plain number or string.  
    Each value generates a 1 or 0 in the result.
    depending on whether or not it is nonzero (True) or nonblank.  None values generate 0.
    bits are assigned right to left.
    If indexes is specified as a string of comma-separated integers, the bit positions 
    listed are inserted in the order listed according to the values
    values must have the same length as the number of indexes given if indexes are used.
    
    E.g., packDummies(1, indexes="5")
    would insert a 1 bit in the 5th position.
    packDummies([1,0,1], indexes="5,6,7")
    would insert a 1 bit in positions 5 and 7 and a 0 in 6
    
    The values are inserted by default in an initial value of 0.  If initial is specified, it will
    be used as the starting value.
    
    """
    
    if initial:
        result = initial
    else:
        result = 0
    if not spssaux._isseq(values):
        values = [values]

    if indexes:
        indexes = [int(v) for v in re.split("[ ,]", indexes)]
        if len(indexes) != len(values):
            raise ValueError("The number of indexes does not match the number of values")
        for i, item in enumerate(indexes):
            if item > 53:
                raise ValueError("Index item must be <= 53.  Value: " + item)
            if values[i]:
                result |= 1<<item   # set a bit
            else:
                result &= ~(1<<item)  # clear a bit
    else:
        if len(values) > 53:
            raise ValueError("A maximum of 53 values can be encoded in a single variable.")
        for i,v in enumerate(values):
            if v:
                result |= 1<<i
            else:
                result &= ~(1<<i)
    return float(result)
        
    
def mode(*args):
    """Return the mode of a list of one or more variables and a count of modal values.
    
    args is a sequence of values
    In case there is a tie, an arbitrary mode is picked.
    The number of modes is returned as the second value"""
    
    counts = {}
    for v in args:
        counts[v] = counts.get(v, 0) + 1
        
    res = sorted([(v,k) for k, v in list(counts.items())], reverse = True)
    themode = res[0][1]
    thecount = [k for k,v in res].count(res[0][0])
    return themode, thecount
    
def multimode(args, maxvalues=1, omitmissing=True):
    """Return the modes of a list of one or more variables up to maxreturn values
    
    args is a sequence of values
    The maximum number of modes to return is maxreturn, default 1
    if omitmissing is True, the default, system-missing values (None) are omitted from the 
    calculation."""
    
    counts = {}
    for v in args:
        if v is not None or (v is None and not omitmissing):
            counts[v] = counts.get(v, 0) + 1
        
    res = sorted([(v,k) for k, v in list(counts.items())], reverse = True)
    themodes = [v for k,v in res if k == res[0][0]]
    return themodes[:maxvalues]

def translatechar(ch, instr, outstr, copyother=True, other=""):
    """map characters into other characters
    
    ch is a character string to be mapped.  Trailing blanks are stripped.
    Each character is replaced by it mapping.
    instr and outstr form a dictionary that defines the mapping
    The shorter of the two strings limits the definition of the mapping.
    The contents of instr should be unique.  If a character is repeated, the
    last use wins.
    If copyother is True, the default, characters not listed in instr will be
    copied.  Otherwise, they will be replaced by the value of other.
    other defines a character to use if no mapping is defined for a character, 
    and copyother is False, defaulting to empty.
    
    If run from SPSSINC TRANS, it will take advantage of that to set up
    a mapping dictionary once for a data pass."""
    ch = ch.rstrip()
    try:
        m = sys.modules["SPSSINC_TRANS"]
        if m.FIRST:
            m.FIRST = False
            m._ = dict(list(zip(instr, outstr)))  # stops when the shorter list is exhaused
            m.other = other
        return "".join([m._.get(c, copyother and c or m.other) for c in ch]) 
    except (KeyError, AttributeError):   # not set up for initialization call
        result = []
        for c in ch:
            try:    
                result.append(outstr[instr.index(c)])
            except:
                result.append(copyother and c or other)
        return "".join(result)
    
import datetime
from spssdata import CvtSpssDatetime

daynumbers = {'mon':0, 'tue':1, 'wed':2,'thu':3,'fri':4,'sat':5,'sun':6}
oneday = datetime.timedelta(1)

# usage example
# SPSSINC TRANS result = diff
# /formula "extendedTransforms.countWkdays(startdate=startdate,enddate=enddate)".
# where startdate and enddate are SPSS date variables

def countWkdays(startdate, enddate, inclusive=True, exclude=None):
    """Count days between start and end dates that are not in excluded days
    
    start and end are dates in SPSS date formats with start <= end.
    inclusive = True includes the end date; False omits it.
    exclude is a list defining the days to be omitted using 3-letter day names in lower case.
    The time portion of a date is ignored."""
    
    # function does not try to be tricky: it just iterates over the days.
    # It could be slow for wide intervals.
    
    if exclude is None:
        exclude = ["sat", "sun"]
    startdate = CvtSpssDatetime(startdate).date()
    enddate = CvtSpssDatetime(enddate).date()
    omit = set([daynumbers[item] for item in exclude]) # will raise exception if bad input
    daykt = 0
    if inclusive:
        enddate = enddate + oneday
    while startdate < enddate:
        dow = startdate.weekday()
        if not dow in omit:
            daykt += 1
        startdate += oneday
    return daykt

# example usage
#spssinc trans result = daysexclusive 
    #/initial  'extendedTransforms.countDaysWExclusions(exclusionds="holidays", exclusionvar="thedate")'
    #/formula 'func(startdate=start, enddate=end)'.

class countDaysWExclusions(object):
    """Count days between start and end dates that are not in excluded days and dates
    
    The active dataset must have a name in order to use an exclusion dataset."""
    
    def __init__(self, exclusionds=None, exclusionvar="dates"):
        
        """exclusionds is the name of the dataset containing the
        dates to exclude.
        exclusionvar is the name of the variable in the dataset
        whose values should be used"""
        
        self.exdates = set()
        if exclusionds:
            activeds = spss.ActiveDataset()
            if activeds == "*":
                raise ValueError("The active dataset must have a name to use countDaysWExclusions")
            try:
                self.exdates = Spssdata(exclusionvar, dataset=exclusionds).fetchall()
                self.exdates = set([CvtSpssDatetime(item[0]).date() for item in self.exdates])
            finally:    # make sure that original dataset remains active
                spss.Submit("DATASET ACTIVATE %s" % activeds)    
        
        def f(startdate, enddate, inclusive=False, exclude=None):
            """Return count of included days
            
            start and end are dates in SPSS date formats.  If
                start > end, the result is negative.
            inclusive = True includes the end date; False omits it.
            exclude is a list defining the days of the week
                to be omitted using 3-letter day names in lower case
                (mon, tue, wed, thu, fri, sat, sun)
            The time portion of a date is ignored.
            inclusive, exclude, exclusionds, and exclusionvar are optional."""
        
            # f knows the self value without it being a parameter
            
            # function does not try to be tricky: it just iterates over the days.
            # It could be slow for wide intervals.
            
            try:
                startdate = CvtSpssDatetime(startdate).date()
                enddate = CvtSpssDatetime(enddate).date()
            except:
                return None   # sysmis if either endpoint is missing
            if exclude:
                omit = set([daynumbers[item] for item in exclude]) # will raise exception if bad input
            else:
                omit = set()
          
            if startdate <= enddate:
                o = operator.le
                inc = operator.add
            else:
                o = operator.ge
                inc = operator.sub

            
            daykt = 0
            while o(startdate, enddate):
                dow = startdate.weekday()
                if not (dow in omit or startdate in self.exdates):
                    if inclusive or startdate != enddate:
                        daykt = inc(daykt, 1)
                startdate = inc(startdate, oneday)
            return daykt
        self.func = f
    
# An implementation of the Dice string similarity measure
def _bigrams(s, casesensitive=False, splitwhite=True):
    """Return a set of bigrams
    
    s is a string
    casesensitive indicates whether to ignore case or not
    splitwhite indicates whether to consider white space as a boundary
    in computing the bigrams.  Only affects multiword strings.
    """
    
    if not casesensitive:
        s = s.lower()
    if splitwhite:
        s = s.split()
    else:
        s = [s.rstrip()]
    result = set()
    for token in s:
        result.update([token[i:i+2] for i in range(len(token) - 1)])
    return result
        
def DiceStringSimilarity(s1, s2, casesensitive=False, splitwhite=True):
    """Return a Dice match statistic for two strings
    The value is 1 if the strings are identical and 0 if they have no
    bigrams in common.
    
    s1 and s2 are the strings to compare.
    casesensitive indicates whether bigrams are case sensitive.
    splitwhite indicates whether to treat each word separately
    in computing bigrams where a word is defined by whitespace.
    Preprocess the text with a regular expression if you want a
    different definition of a word."""
    
    a = _bigrams(s1, False, splitwhite)
    b = _bigrams(s2, False, splitwhite)
    
    matches = len(a.intersection(b))
    return (matches * 2.) / max(len(a) + len(b), 1)

# Use Dice to find closest match to the items in a dataset
# using SPSSINC TRANS.
#example:
#data list free/words(a10).
#begin data.
#'Heard', 'Healthy', 'Help', 'Herded', 'Sealed', 'Sold', "Healed", '', 'heard', 'xyz'
#end data.
#dataset name words.

#data list list/asks(a9).
#begin data
#"heart"
#"Herded"
#"abc"
#"xyz"
#"helped"
#"help"
#end data.
#dataset name asks.
#exec.

#dataset activate asks.
#spssinc trans result=best type=10
#/initial "extendedTransforms.Dicedict(wordds='words', stringsvar='words',casesensitive=False)"
#/formula "func(asks)".
class Dicedict(object):
    # manage a batch of word matches
    def __init__(self, wordds, stringsvar, casesensitive=False, splitwhite=True):
        """Get all the words from the word dataset
        
        wordds is the dataset of words
        stringsvar is the variable in that dataset containing the words
        casesensitive and splitwhite are arguments to DiceStringSimilarity"""
        
        self.strings = []
        activeds = spss.ActiveDataset()
        if activeds == "*":
            raise ValueError("The active dataset must have a name in order to use this function")
        try:
            self.strings = Spssdata(stringsvar, dataset=wordds).fetchall()
            self.strings = [item[0] for item in self.strings]
        finally:    # make sure that original dataset remains active
            spss.Submit("DATASET ACTIVATE %s" % activeds)
            
        def f(s):
            similarity = max([(DiceStringSimilarity(s, s2, casesensitive, splitwhite), s2) for s2 in self.strings])
            return similarity[1]
        self.func = f
    
def setRandomSeed(value):
    """Set the random number seed.
    
    If value is None, initialize the seed from the clock"""
    
    if value is None:
        random.seed()
    else:
        random.seed(value)
        
def invGaussian(mu, lambdap):
    """Return random number from the inverse Gaussian distribution
    mu >0 is the mean and lambdap is the shape parameter aka lambda"""
    
    y = random.gauss(0, 1)**2
    z = random.uniform(0,1)
    x = mu + (mu*mu*y)/(2*lambdap) - (mu/2*lambdap) * math.sqrt(4*mu*lambdap*y + mu*mu*y*y)
    
    if z <= mu/(mu+x):
        return x
    else:
        return mu*mu/x
    
def triangular(a, b, c):
    """Return triangular random number
    
    a and b are the left and right limits
    c is the peak"""
    
    Fc = (c-a) / (b-a)
    u = random.uniform(0,1)
    if u < Fc:
        return a + math.sqrt(u * (b - a) * (c - a))
    else:
        return b - math.sqrt((1-u) * (b-a) * (b - c))
    